Exercice jour 3 :
Créer une nouvelle arme qui hérite de AWeapon
Choisissez le game design de cette arme (shotgun ?)
Implémenter l'arme de la même manière que Rifle ou Gun mais suivant votre design



Exercice jour 4 : 

Refactor le comportement des projectiles avec une classe abstraite qui représente un projectile.
Ajouter (en classe dérivée) un projectile par défaut similaire au projectile déjà existant.
Ajouter un nouveau projectile qui vous designerez.


Spherical Linear Interpolation
SLERP

Exercice jour 4 / 5:
Créer une architecture répondant aux consignes suivantes :
- Un script Tower
	- Capable de savoir si un damageable est dans sa range
	- Instancie un projectile qui se dirige vers le damageable
	- Si le projectile touche le damageable, il lui retire de la vie (<- réutilisez ce qui existe)

- Bonus
	- La tour dispose d'un canon à partir duquel le projectile est instancié
	- le canon de la tour se tourne instantanément vers le damageable dans la range.
	- Le chapeau se tourne dans le temps (cherchez doc unity : Slerp) avant de tirer sur le damageable.
	- Une particule est instanciée avec le projectile à la création (sign) 
	- Une particule est instanciée quand le projectile touche un damageable

Conseils :
	- Divide and conquer : diviser chacune des étapes en petits bouts que vous assemblez au fur et à mesure
	- Réfléchissez au contexte de chaque étape (e.g. qui détient la particule instanciée par le projectile quand on touche un damageable ?)
	- Réutilisez ce qu'on connait :
		- Séparer des comportements différents en fonction d'état avec un enum / switch (si je suis dans la state x, je fais ça, sinon ça...)
		- la formule pour trouver une direction
		- la class Timer pour attendre x secondes
		- l'utilisation de Quaternion.Euler et LookRotation, etc...