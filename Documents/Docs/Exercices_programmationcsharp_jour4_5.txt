Exercice jour 3 :
Créer une nouvelle arme qui hérite de AWeapon
Choisissez le game design de cette arme (shotgun ?)
Implémenter l'arme de la même manière que Rifle ou Gun mais suivant votre design



Exercice jour 4 : 

Refactor le comportement des projectiles avec une classe abstraite qui représente un projectile.
Ajouter (en classe dérivée) un projectile par défaut similaire au projectile déjà existant.
Ajouter un nouveau projectile qui vous designerez.


Spherical Linear Interpolation
SLERP

Exercice jour 4 / 5:
Créer une architecture répondant aux consignes suivantes :
- Un script Tower
	- Capable de savoir si un damageable est dans sa range
	- Instancie un projectile qui se dirige vers le damageable
	- Si le projectile touche le damageable, il lui retire de la vie (<- réutilisez ce qui existe)

- Bonus
	- La tour dispose d'un canon à partir duquel le projectile est instancié
	- le canon de la tour se tourne instantanément vers le damageable dans la range.
	- Le chapeau se tourne dans le temps (cherchez doc unity : Slerp) avant de tirer sur le damageable.
	- Une particule est instanciée avec le projectile à la création (sign) 
	- Une particule est instanciée quand le projectile touche un damageable

Conseils :
	- Divide and conquer : diviser chacune des étapes en petits bouts que vous assemblez au fur et à mesure
	- Réfléchissez au contexte de chaque étape (e.g. qui détient la particule instanciée par le projectile quand on touche un damageable ?)
	- Réutilisez ce qu'on connait :
		- Séparer des comportements différents en fonction d'état avec un enum / switch (si je suis dans la state x, je fais ça, sinon ça...)
		- la formule pour trouver une direction
		- la class Timer pour attendre x secondes
		- l'utilisation de Quaternion.Euler et LookRotation, etc...




Exercice jour 7 :
	- Reproduire le comportement de TowerCount avec un nouvel objet ActorCount -> Du UI qui renvoit le nombre d'actor dans la semaine dynamiquement




Exercice jour 8 :

- Ajouter à DamageableParticleHandler une série de règles (quand la vie est comme ceci ou comme cela) qui déclenchent des feedbacks différents et reconnaissable.

 OBLIGATOIRE :
 	- Une particle de hit est lancée quand un damageable se prends un dégats
 	- Une particle de kill est lancée quand un damageable est détruit

Bonus (exemple) :
	- Si le dégat est supérieur à X (valeur en dur ou relative, par ex à la max health), on lance une particle différentes
	- Si la vie du damageable est en dessous d'une certaine valeur, déclencher un feedback différent (plusieurs paliers possibles)


Exercice jour 9 :

- Modifier la scène Game 
	- un petit level design avec deux trois slots de tours, un chemin qui passe à côté, un spawner au bout de ce chemin
	- la base du joueur au bout du chemin, contenant des points de vie, point de vie qui sont réduits quand un actor rentre dans son trigger
	- Ajouter une barre de vie joueur dans le HUD 


- Ajouter un système économique :
	- Un manager qui détient les données courante (combien d'argent j'ai, etcf...)
	- Un HUD qui affiche la thune
	- Des actors qui donne de l'argent au joueur quand il est détruit
	- Des tower pickers qui dépensent de l'argent quand une tour est construite

	Pour vous aider :
		- Pensez "manager unique et accessible par tous le monde". LevelReference.Instance.VotreManagerDeSystèmeEco
		- Éventuellement utiliser des events !




A faire ensemble : 

	- Camera billboard health bar
	- Système eco
	- hud selection tower
	- feedback range tower
